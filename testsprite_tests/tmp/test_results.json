[
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "3571253c-871a-444a-82f3-807a998ed016",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC001-customer multi step booking form functionality",
    "description": "Verify that the multi-step booking form allows customers to select customer type, enter contact information, choose service types, specify move details and addresses, select inventory and additional services, and view a summary with real-time price calculation and address autocompletion.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nBOOKINGS_ENDPOINT = f\"{BASE_URL}/api/bookings\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_customer_multi_step_booking_form_functionality():\n    \"\"\"\n    Test the multi-step booking form workflow:\n    - Select customer type\n    - Enter contact information\n    - Choose service types\n    - Specify move details and addresses\n    - Select inventory and additional services\n    - View summary with real-time price calculation and address autocompletion\n    \"\"\"\n    # Step 1: Select customer type and provide basic info\n    booking_data = {\n        \"customerType\": \"private\",  # could be \"company\" in other cases\n        \"contactInformation\": {\n            \"firstName\": \"Test\",\n            \"lastName\": \"Customer\",\n            \"email\": \"test.customer@example.com\",\n            \"phone\": \"+4712345678\"\n        },\n        \"serviceTypes\": [\n            \"full_move\",  # example service type\n            \"packing\"\n        ],\n        \"moveDetails\": {\n            \"moveDate\": (time.strftime(\"%Y-%m-%d\")),\n            \"fromAddress\": \"Karl Johans gate 1, Oslo, Norway\",\n            \"toAddress\": \"Dronning Eufemias gate 10, Oslo, Norway\",\n            \"volumeCbm\": 30,  # estimated volume in cubic meters\n            \"distanceKm\": 5\n        },\n        \"inventory\": [\n            {\"item\": \"Sofa\", \"quantity\": 1},\n            {\"item\": \"Box\", \"quantity\": 10}\n        ],\n        \"additionalServices\": [\n            \"disassembly\",\n            \"storage\"\n        ]\n    }\n\n    booking_id = None\n\n    try:\n        # Create booking (multi-step form submit sim in one request)\n        response = requests.post(\n            BOOKINGS_ENDPOINT,\n            json=booking_data,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}\"\n        booking_response = response.json()\n        booking_id = booking_response.get(\"id\")\n        assert booking_id is not None, \"Booking ID should be returned on creation\"\n\n        # Validate response contains key booking details\n        assert booking_response.get(\"customerType\") == booking_data[\"customerType\"]\n        assert booking_response.get(\"contactInformation\", {}).get(\"email\") == booking_data[\"contactInformation\"][\"email\"]\n        assert \"priceSummary\" in booking_response, \"Price summary must be included with real-time calculation\"\n        price_summary = booking_response[\"priceSummary\"]\n        assert isinstance(price_summary.get(\"totalPrice\"), (int, float)), \"Total price should be a number\"\n        assert price_summary.get(\"addressAutocomplete\") is True or price_summary.get(\"addressAutocomplete\") is None or isinstance(price_summary.get(\"addressAutocomplete\"), bool), \"Address autocomplete flag or similar expected\"\n\n        # Simulate getting updated price after changing move details (address autocompletion and distance recalculation)\n        updated_move_details = {\n            \"moveDate\": booking_data[\"moveDetails\"][\"moveDate\"],\n            \"fromAddress\": \"Karl Johans gate 2, Oslo, Norway\",  # slight address change for autocomplete test\n            \"toAddress\": \"Dronning Eufemias gate 12, Oslo, Norway\",\n            \"volumeCbm\": 32,\n            \"distanceKm\": 6\n        }\n        update_payload = {\n            \"moveDetails\": updated_move_details\n        }\n        update_resp = requests.put(\n            f\"{BOOKINGS_ENDPOINT}/{booking_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Expected 200 OK on update, got {update_resp.status_code}\"\n        updated_data = update_resp.json()\n        assert updated_data[\"moveDetails\"][\"fromAddress\"] == updated_move_details[\"fromAddress\"]\n        assert updated_data[\"moveDetails\"][\"toAddress\"] == updated_move_details[\"toAddress\"]\n        assert \"priceSummary\" in updated_data, \"Updated price summary must be returned after move details change\"\n        assert updated_data[\"priceSummary\"][\"totalPrice\"] != price_summary[\"totalPrice\"], \"Price should be recalculated after move detail update\"\n\n    finally:\n        # Cleanup: Delete created booking if created\n        if booking_id:\n            del_resp = requests.delete(\n                f\"{BOOKINGS_ENDPOINT}/{booking_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert del_resp.status_code in (200, 204), f\"Expected 200 or 204 on delete, got {del_resp.status_code}\"\n\ntest_customer_multi_step_booking_form_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 106, in <module>\n  File \"<string>\", line 59, in test_customer_multi_step_booking_form_functionality\nAssertionError: Expected 201 Created, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.342Z",
    "modified": "2025-08-27T12:14:37.506Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "e5226404-3e76-424b-bc4b-1d641fa19448",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC002-offer viewer interactive features",
    "description": "Test the offer viewer page to ensure customers can interactively select services, view detailed price breakdowns including RUT deductions, visualize timelines, accept or decline offers, make direct payments, and use chat support.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Add Authorization header if API requires authentication\n}\n\n\ndef test_offer_viewer_interactive_features():\n    timeout = 30\n    offer_id = None\n    chat_message_id = None\n\n    # Step 1: Create a sample offer resource to test with (simulate an offer creation)\n    offer_payload = {\n        \"customer_type\": \"private\",\n        \"customer_id\": \"test-customer-001\",\n        \"services\": [\n            {\n                \"service_type\": \"standard_moving\",\n                \"quantity\": 1,\n                \"selected\": True\n            },\n            {\n                \"service_type\": \"packing_service\",\n                \"quantity\": 1,\n                \"selected\": False\n            }\n        ],\n        \"price_breakdown\": {\n            \"base_price\": 5000,\n            \"rut_deduction\": 1250,\n            \"taxes\": 600,\n            \"total\": 4350\n        },\n        \"timeline\": [\n            {\"step\": \"Quote sent\", \"date\": \"2025-09-01T10:00:00Z\"},\n            {\"step\": \"Offer expires\", \"date\": \"2025-09-08T23:59:59Z\"}\n        ],\n        \"status\": \"pending\"\n    }\n\n    try:\n        # Create offer\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/offers\",\n            json=offer_payload,\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert create_resp.status_code == 201, f\"Offer creation failed: {create_resp.text}\"\n        created_offer = create_resp.json()\n        assert \"id\" in created_offer, \"Created offer missing 'id'\"\n        offer_id = created_offer[\"id\"]\n\n        # Step 2: Retrieve offer and verify interactive features presence\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/offers/{offer_id}\",\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert get_resp.status_code == 200, f\"Failed to get offer: {get_resp.text}\"\n        offer = get_resp.json()\n\n        # Verify services field and price breakdown including RUT deduction\n        assert \"services\" in offer and isinstance(offer[\"services\"], list), \"Services missing or invalid\"\n        assert any(s[\"selected\"] for s in offer[\"services\"]), \"No selected service found\"\n        assert \"price_breakdown\" in offer, \"Price breakdown missing\"\n        price_bd = offer[\"price_breakdown\"]\n        assert \"rut_deduction\" in price_bd, \"RUT deduction missing in price breakdown\"\n        assert price_bd[\"total\"] == price_bd[\"base_price\"] - price_bd[\"rut_deduction\"] + price_bd.get(\"taxes\", 0), \\\n            \"Price total calculation mismatch\"\n\n        # Verify timeline visualization info present\n        assert \"timeline\" in offer and isinstance(offer[\"timeline\"], list), \"Timeline missing or invalid\"\n        assert len(offer[\"timeline\"]) > 0, \"Timeline is empty\"\n\n        # Step 3: Simulate interactive service selection toggle\n        # Toggle packing_service selected to True\n        updated_services = []\n        for svc in offer[\"services\"]:\n            if svc[\"service_type\"] == \"packing_service\":\n                updated_services.append({**svc, \"selected\": True})\n            else:\n                updated_services.append(svc)\n        # Update entire offer with updated services\n        patch_payload = {\"services\": updated_services}\n        patch_resp = requests.put(\n            f\"{BASE_URL}/api/offers/{offer_id}\",\n            json=patch_payload,\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert patch_resp.status_code == 200, f\"Failed to update services: {patch_resp.text}\"\n        updated_offer = patch_resp.json()\n        assert any(s.get(\"service_type\") == \"packing_service\" and s.get(\"selected\") for s in updated_offer[\"services\"]), \\\n            \"Service selection update failed\"\n\n        # Step 4: Accept the offer\n        accept_resp = requests.post(\n            f\"{BASE_URL}/api/offers/{offer_id}/accept\",\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert accept_resp.status_code == 200, f\"Failed to accept offer: {accept_resp.text}\"\n        accept_data = accept_resp.json()\n        assert accept_data.get(\"status\") == \"accepted\", \"Offer not marked accepted\"\n\n        # Step 5: Attempt to decline (should error or be forbidden since accepted)\n        decline_resp = requests.post(\n            f\"{BASE_URL}/api/offers/{offer_id}/decline\",\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        # Assuming system returns 400 or 409 or 403 HTTP error when declining accepted offer\n        assert decline_resp.status_code in (400, 403, 409), \"Decline should fail after acceptance\"\n\n        # Step 6: Make a direct payment\n        payment_payload = {\n            \"offer_id\": offer_id,\n            \"payment_method\": \"swish\",\n            \"amount\": updated_offer[\"price_breakdown\"][\"total\"],\n            \"currency\": \"SEK\",\n        }\n        payment_resp = requests.post(\n            f\"{BASE_URL}/api/offers/{offer_id}/payments\",\n            json=payment_payload,\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert payment_resp.status_code == 201, f\"Payment failed: {payment_resp.text}\"\n        payment_data = payment_resp.json()\n        assert payment_data.get(\"status\") == \"paid\", \"Payment status not paid\"\n\n        # Step 7: Use chat support - send a chat message\n        chat_payload = {\n            \"offer_id\": offer_id,\n            \"message\": \"I have a question about my offer.\",\n            \"from_customer\": True\n        }\n        chat_resp = requests.post(\n            f\"{BASE_URL}/api/offers/{offer_id}/chat\",\n            json=chat_payload,\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert chat_resp.status_code == 201, f\"Sending chat message failed: {chat_resp.text}\"\n        chat_message = chat_resp.json()\n        assert \"id\" in chat_message, \"Chat message ID missing\"\n        chat_message_id = chat_message[\"id\"]\n\n        # Retrieve chat messages\n        get_chat_resp = requests.get(\n            f\"{BASE_URL}/api/offers/{offer_id}/chat\",\n            headers=HEADERS,\n            timeout=timeout,\n        )\n        assert get_chat_resp.status_code == 200, f\"Failed to get chat messages: {get_chat_resp.text}\"\n        chat_history = get_chat_resp.json()\n        assert any(msg.get(\"id\") == chat_message_id for msg in chat_history), \"Sent chat message not found in history\"\n\n    finally:\n        # Cleanup: delete created offer and chat message if applicable\n        if chat_message_id and offer_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/offers/{offer_id}/chat/{chat_message_id}\",\n                    headers=HEADERS,\n                    timeout=timeout,\n                )\n            except Exception:\n                pass\n        if offer_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/offers/{offer_id}\",\n                    headers=HEADERS,\n                    timeout=timeout,\n                )\n            except Exception:\n                pass\n\n\ntest_offer_viewer_interactive_features()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 186, in <module>\n  File \"<string>\", line 53, in test_offer_viewer_interactive_features\nAssertionError: Offer creation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.349Z",
    "modified": "2025-08-27T12:15:35.234Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "831c270c-58f6-49f1-a223-e418cb172331",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC003-order confirmation page display",
    "description": "Validate that the order confirmation page correctly displays the order summary, service details, timeline, additional services selected, and provides access to customer support chat.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n# Placeholder auth token for testing; replace with valid token as needed\nAUTH_TOKEN = \"Bearer test-token\"\n\ndef test_order_confirmation_page_display():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": AUTH_TOKEN\n    }\n    booking_data = {\n        \"customerType\": \"private\",\n        \"contactInfo\": {\n            \"email\": \"test.customer@example.com\",\n            \"phone\": \"+46701234567\",\n            \"name\": \"Test Customer\"\n        },\n        \"serviceType\": \"standard_move\",\n        \"moveDetails\": {\n            \"originAddress\": \"123 Start St, Stockholm\",\n            \"destinationAddress\": \"789 End Ave, Gothenburg\",\n            \"moveDate\": \"2025-09-10\"\n        },\n        \"inventory\": [\n            {\"item\": \"sofa\", \"quantity\": 1},\n            {\"item\": \"boxes\", \"quantity\": 10}\n        ],\n        \"additionalServices\": [\n            \"packing_service\",\n            \"assembly_service\"\n        ],\n        \"extraServices\": [],\n        \"summary\": {\n            \"totalPrice\": 0,\n            \"priceBreakdown\": {}\n        },\n        \"pricing\": {\n            \"basePrice\": 0,\n            \"rutDeduction\": 0\n        }\n    }\n\n    booking_id = None\n\n    try:\n        # Create a booking to have an order to confirm\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/bookings\",\n            json=booking_data,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201, f\"Expected 201, got {create_resp.status_code}\"\n        booking_response = create_resp.json()\n        booking_id = booking_response.get(\"id\")\n        assert booking_id is not None, \"Booking ID was not returned in creation response\"\n\n        # Retrieve order confirmation details\n        confirm_resp = requests.get(\n            f\"{BASE_URL}/api/bookings/{booking_id}/confirmation\",\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert confirm_resp.status_code == 200, f\"Expected 200, got {confirm_resp.status_code}\"\n        data = confirm_resp.json()\n\n        # Validate presence and structure of order summary\n        summary = data.get(\"orderSummary\")\n        assert summary is not None, \"Order summary missing in confirmation\"\n        assert isinstance(summary.get(\"totalPrice\"), (int, float)), \"Total price should be a number\"\n\n        # Validate service details\n        service_details = data.get(\"serviceDetails\")\n        assert service_details is not None, \"Service details missing\"\n        assert isinstance(service_details.get(\"serviceType\"), str) and service_details.get(\"serviceType\") != \"\", \"Service type missing or empty\"\n\n        # Validate timeline presence and format\n        timeline = data.get(\"timeline\")\n        assert timeline is not None, \"Timeline data missing\"\n        assert isinstance(timeline, list), \"Timeline should be a list\"\n        assert len(timeline) > 0, \"Timeline list is empty\"\n\n        # Validate additional services selected\n        additional_services = data.get(\"additionalServices\")\n        assert additional_services is not None, \"Additional services missing\"\n        assert set(additional_services) >= set([\"packing_service\", \"assembly_service\"]), \"Additional services do not include expected items\"\n\n        # Validate customer support chat access info\n        support_chat = data.get(\"customerSupportChat\")\n        assert support_chat is not None, \"Customer support chat info missing\"\n        assert \"chatUrl\" in support_chat or \"chatAvailable\" in support_chat, \"Customer support chat keys missing\"\n\n    finally:\n        if booking_id:\n            # Delete created booking to clean up\n            requests.delete(\n                f\"{BASE_URL}/api/bookings/{booking_id}\",\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n\ntest_order_confirmation_page_display()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 56, in test_order_confirmation_page_display\nAssertionError: Expected 201, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.357Z",
    "modified": "2025-08-27T12:15:01.800Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "ec321c6e-5683-493b-ba71-c355c4e3e145",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC004-staff app authentication and dashboard",
    "description": "Test the staff mobile app login using phone and OTP authentication, and verify that the dashboard displays today's jobs with card and list views, including filtering and searching capabilities.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_staff_app_authentication_and_dashboard():\n    phone_number = \"+4712345678\"  # Example test phone number\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        # Step 1: Initiate OTP login by submitting phone number\n        otp_request_payload = {\"phone\": phone_number}\n        otp_request_resp = requests.post(\n            f\"{BASE_URL}/api/staff/auth/request-otp\",\n            json=otp_request_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert otp_request_resp.status_code == 200, f\"OTP request failed: {otp_request_resp.text}\"\n        otp_request_data = otp_request_resp.json()\n        assert \"otpSessionId\" in otp_request_data, \"otpSessionId missing in OTP request response\"\n\n        otp_session_id = otp_request_data[\"otpSessionId\"]\n\n        # NOTE: In real test, OTP would be received on phone.\n        # For test, assume OTP code is retrievable or fixed for test environment.\n        # Use a test OTP code for this purpose:\n        test_otp_code = \"123456\"\n\n        # Step 2: Verify OTP to authenticate and get JWT token\n        otp_verify_payload = {\n            \"otpSessionId\": otp_session_id,\n            \"otpCode\": test_otp_code\n        }\n        otp_verify_resp = requests.post(\n            f\"{BASE_URL}/api/staff/auth/verify-otp\",\n            json=otp_verify_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert otp_verify_resp.status_code == 200, f\"OTP verify failed: {otp_verify_resp.text}\"\n        otp_verify_data = otp_verify_resp.json()\n        assert \"token\" in otp_verify_data, \"JWT token missing in OTP verify response\"\n        auth_token = otp_verify_data[\"token\"]\n        auth_headers = {\n            \"Authorization\": f\"Bearer {auth_token}\"\n        }\n\n        # Step 3: Fetch staff dashboard for today's jobs with default view (card)\n        dashboard_resp = requests.get(\n            f\"{BASE_URL}/api/staff/dashboard?view=card&date=today\",\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert dashboard_resp.status_code == 200, f\"Dashboard fetch failed: {dashboard_resp.text}\"\n        dashboard_data = dashboard_resp.json()\n        assert \"jobs\" in dashboard_data, \"Dashboard response missing jobs key\"\n        jobs_list = dashboard_data[\"jobs\"]\n        # jobs can be empty but should be a list\n        assert isinstance(jobs_list, list), \"Jobs should be a list\"\n\n        # Step 4: Fetch dashboard with list view\n        dashboard_list_resp = requests.get(\n            f\"{BASE_URL}/api/staff/dashboard?view=list&date=today\",\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert dashboard_list_resp.status_code == 200, f\"Dashboard list view fetch failed: {dashboard_list_resp.text}\"\n        dashboard_list_data = dashboard_list_resp.json()\n        assert \"jobs\" in dashboard_list_data, \"Dashboard list response missing jobs key\"\n        assert isinstance(dashboard_list_data[\"jobs\"], list), \"Jobs should be a list in list view\"\n\n        # Step 5: Test filtering jobs by status - example filter: 'open'\n        filter_params = {\n            \"view\": \"card\",\n            \"date\": \"today\",\n            \"status\": \"open\"\n        }\n        filter_resp = requests.get(\n            f\"{BASE_URL}/api/staff/dashboard\",\n            headers=auth_headers,\n            params=filter_params,\n            timeout=TIMEOUT\n        )\n        assert filter_resp.status_code == 200, f\"Dashboard filter fetch failed: {filter_resp.text}\"\n        filter_data = filter_resp.json()\n        assert \"jobs\" in filter_data, \"Filtered dashboard response missing jobs key\"\n        assert isinstance(filter_data[\"jobs\"], list), \"Jobs should be a list in filtered response\"\n        # If jobs exist, check all have status 'open'\n        for job in filter_data[\"jobs\"]:\n            assert job.get(\"status\") == \"open\", f\"Job status mismatch in filter: {job}\"\n\n        # Step 6: Test searching jobs by keyword in dashboard\n        search_keyword = \"move\"\n        search_params = {\n            \"view\": \"list\",\n            \"date\": \"today\",\n            \"search\": search_keyword\n        }\n        search_resp = requests.get(\n            f\"{BASE_URL}/api/staff/dashboard\",\n            headers=auth_headers,\n            params=search_params,\n            timeout=TIMEOUT\n        )\n        assert search_resp.status_code == 200, f\"Dashboard search fetch failed: {search_resp.text}\"\n        search_data = search_resp.json()\n        assert \"jobs\" in search_data, \"Search dashboard response missing jobs key\"\n        assert isinstance(search_data[\"jobs\"], list), \"Jobs should be a list in search response\"\n        # If jobs returned, verify keyword presence in job title or description\n        for job in search_data[\"jobs\"]:\n            title = job.get(\"title\", \"\").lower()\n            desc = job.get(\"description\", \"\").lower()\n            assert search_keyword in title or search_keyword in desc, f\"Job does not match search keyword: {job}\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n\n\ntest_staff_app_authentication_and_dashboard()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 122, in <module>\n  File \"<string>\", line 21, in test_staff_app_authentication_and_dashboard\nAssertionError: OTP request failed: {\"error\":\"Authentication required\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.365Z",
    "modified": "2025-08-27T12:14:39.949Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "620aba56-c9b2-401e-b074-0686408fc1e9",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC005-staff job management features",
    "description": "Verify that staff can manage job statuses, complete pre-start checklists, log GPS locations, track time, take photo documentation, request additional services, adjust volumes, and use the smart pricing engine within the job management module.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n# Dummy staff authentication to retrieve a JWT token for authorization\ndef staff_login(phone=\"+1234567890\", otp=\"123456\"):\n    login_url = f\"{BASE_URL}/api/staff/login\"\n    resp = requests.post(login_url, json={\"phone\": phone, \"otp\": otp}, timeout=TIMEOUT)\n    resp.raise_for_status()\n    token = resp.json().get(\"token\")\n    if not token:\n        raise Exception(\"Failed to retrieve staff auth token\")\n    return token\n\ndef test_staff_job_management_features():\n    token = staff_login()\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n    # Step 1: Create a new job resource for testing\n    create_job_payload = {\n        \"customer_id\": 1,  # Assuming customer with ID 1 exists for testing\n        \"service_type\": \"standard_moving\",\n        \"scheduled_start\": \"2025-09-01T08:00:00Z\",\n        \"volume_estimate\": 10,\n        \"address_pickup\": \"123 Origin St, City A\",\n        \"address_destination\": \"456 Destination Rd, City B\",\n        \"status\": \"scheduled\"\n    }\n    job_create_resp = requests.post(f\"{BASE_URL}/api/jobs\", headers=headers, json=create_job_payload, timeout=TIMEOUT)\n    assert job_create_resp.status_code == 201, f\"Job creation failed: {job_create_resp.text}\"\n    job = job_create_resp.json()\n    job_id = job[\"id\"]\n\n    try:\n        # Step 2: Update job status\n        status_update_payload = {\"status\": \"in_progress\"}\n        resp_status = requests.put(f\"{BASE_URL}/api/jobs/{job_id}/status\", headers=headers, json=status_update_payload, timeout=TIMEOUT)\n        assert resp_status.status_code == 200\n        assert resp_status.json().get(\"status\") == \"in_progress\"\n\n        # Step 3: Complete pre-start checklist\n        checklist_payload = {\n            \"completed_items\": [\n                \"vehicle_checked\",\n                \"equipment_ready\",\n                \"safety_gear_worn\"\n            ]\n        }\n        resp_checklist = requests.post(f\"{BASE_URL}/api/jobs/{job_id}/prestart-checklist\", headers=headers, json=checklist_payload, timeout=TIMEOUT)\n        assert resp_checklist.status_code == 200\n        checklist_resp_json = resp_checklist.json()\n        assert checklist_resp_json.get(\"checklist_completed\") is True or len(checklist_resp_json.get(\"completed_items\", [])) == 3\n\n        # Step 4: Log GPS location\n        gps_payload = {\"latitude\": 59.3293, \"longitude\": 18.0686, \"timestamp\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())}\n        resp_gps = requests.post(f\"{BASE_URL}/api/jobs/{job_id}/gps-log\", headers=headers, json=gps_payload, timeout=TIMEOUT)\n        assert resp_gps.status_code == 201\n        gps_log = resp_gps.json()\n        assert gps_log.get(\"latitude\") == gps_payload[\"latitude\"]\n        assert gps_log.get(\"longitude\") == gps_payload[\"longitude\"]\n\n        # Step 5: Start time tracking\n        resp_start_time = requests.post(f\"{BASE_URL}/api/jobs/{job_id}/time-tracking/start\", headers=headers, timeout=TIMEOUT)\n        assert resp_start_time.status_code == 200\n        assert resp_start_time.json().get(\"tracking\") is True\n\n        # Wait for 1 second to simulate some elapsed time\n        time.sleep(1)\n\n        # Step 6: Stop time tracking\n        resp_stop_time = requests.post(f\"{BASE_URL}/api/jobs/{job_id}/time-tracking/stop\", headers=headers, timeout=TIMEOUT)\n        assert resp_stop_time.status_code == 200\n        elapsed = resp_stop_time.json().get(\"elapsed_seconds\")\n        assert isinstance(elapsed, int) and elapsed >= 1\n\n        # Step 7: Upload photo documentation\n        photo_upload_url = f\"{BASE_URL}/api/jobs/{job_id}/photo\"\n        # For test purposes, upload dummy bytes as photo (simulate jpeg)\n        photo_files = {\"file\": (\"photo.jpg\", b\"\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\", \"image/jpeg\")}\n        resp_photo = requests.post(photo_upload_url, headers={\"Authorization\": f\"Bearer {token}\"}, files=photo_files, timeout=TIMEOUT)\n        assert resp_photo.status_code == 201\n        photo_data = resp_photo.json()\n        assert \"photo_url\" in photo_data\n\n        # Step 8: Request additional services\n        additional_service_payload = {\n            \"service_name\": \"packing_help\",\n            \"quantity\": 2,\n            \"notes\": \"Need assistance with packing fragile items.\"\n        }\n        resp_add_service = requests.post(f\"{BASE_URL}/api/jobs/{job_id}/additional-services\", headers=headers, json=additional_service_payload, timeout=TIMEOUT)\n        assert resp_add_service.status_code == 201\n        added_service = resp_add_service.json()\n        assert added_service.get(\"service_name\") == \"packing_help\"\n        assert added_service.get(\"quantity\") == 2\n\n        # Step 9: Adjust volumes\n        volume_adjust_payload = {\"volume_estimate\": 12}\n        resp_volume = requests.put(f\"{BASE_URL}/api/jobs/{job_id}/volume\", headers=headers, json=volume_adjust_payload, timeout=TIMEOUT)\n        assert resp_volume.status_code == 200\n        assert resp_volume.json().get(\"volume_estimate\") == 12\n\n        # Step 10: Use smart pricing engine to get updated price\n        resp_smart_price = requests.get(f\"{BASE_URL}/api/jobs/{job_id}/smart-price\", headers=headers, timeout=TIMEOUT)\n        assert resp_smart_price.status_code == 200\n        smart_price_resp = resp_smart_price.json()\n        assert \"price\" in smart_price_resp\n        assert isinstance(smart_price_resp[\"price\"], (int, float))\n        assert smart_price_resp[\"price\"] > 0\n\n    finally:\n        # Clean up: delete the test job\n        delete_resp = requests.delete(f\"{BASE_URL}/api/jobs/{job_id}\", headers=headers, timeout=TIMEOUT)\n        # Allow 404 in case the job was already deleted\n        assert delete_resp.status_code in (200, 204, 404)\n\n\ntest_staff_job_management_features()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 120, in <module>\n  File \"<string>\", line 18, in test_staff_job_management_features\n  File \"<string>\", line 11, in staff_login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3001/api/staff/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.371Z",
    "modified": "2025-08-27T12:14:38.380Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "3b032fa7-7f9a-4ab3-a8e0-258ad52c34d5",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC006-crm dashboard and modules functionality",
    "description": "Ensure the CRM dashboard and modules for customers, leads, jobs, staff, calendar, offers, finance, inventory, and suppliers function correctly with accurate data syncing and real-time updates.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nHEADERS = {\n    \"Accept\": \"application/json\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_crm_dashboard_and_modules_functionality():\n    \"\"\"\n    Test CRM dashboard and modules for customers, leads, jobs, staff, calendar,\n    offers, finance, inventory, and suppliers for correct functionality,\n    accurate data syncing, and real-time updates.\n    \"\"\"\n    # Helper function to create a minimal test resource to ensure data exists\n    def create_customer():\n        payload = {\n            \"name\": \"Test Customer\",\n            \"email\": \"testcustomer@example.com\",\n            \"phone\": \"0700000000\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/customers\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_customer(customer_id):\n        resp = requests.delete(f\"{BASE_URL}/api/customers/{customer_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete customer with id {customer_id}\")\n\n    def create_lead():\n        payload = {\n            \"name\": \"Test Lead\",\n            \"email\": \"testlead@example.com\",\n            \"status\": \"new\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/leads\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_lead(lead_id):\n        resp = requests.delete(f\"{BASE_URL}/api/leads/{lead_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete lead with id {lead_id}\")\n\n    def create_job(customer_id):\n        payload = {\n            \"customerId\": customer_id,\n            \"description\": \"Test Job\",\n            \"status\": \"scheduled\",\n            \"scheduledDate\": time.strftime(\"%Y-%m-%d\")\n        }\n        resp = requests.post(f\"{BASE_URL}/api/jobs\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_job(job_id):\n        resp = requests.delete(f\"{BASE_URL}/api/jobs/{job_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete job with id {job_id}\")\n\n    def create_staff():\n        payload = {\n            \"name\": \"Test Staff\",\n            \"email\": \"teststaff@example.com\",\n            \"role\": \"employee\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/staff\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_staff(staff_id):\n        resp = requests.delete(f\"{BASE_URL}/api/staff/{staff_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete staff with id {staff_id}\")\n\n    def create_calendar_event():\n        payload = {\n            \"title\": \"Test Event\",\n            \"start\": time.strftime(\"%Y-%m-%dT09:00:00Z\"),\n            \"end\": time.strftime(\"%Y-%m-%dT10:00:00Z\"),\n            \"resourceId\": \"test_resource\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/calendar/events\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_calendar_event(event_id):\n        resp = requests.delete(f\"{BASE_URL}/api/calendar/events/{event_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete calendar event with id {event_id}\")\n\n    def create_offer():\n        payload = {\n            \"title\": \"Test Offer\",\n            \"status\": \"draft\",\n            \"customerId\": None\n        }\n        resp = requests.post(f\"{BASE_URL}/api/offers\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_offer(offer_id):\n        resp = requests.delete(f\"{BASE_URL}/api/offers/{offer_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete offer with id {offer_id}\")\n\n    def create_finance_record():\n        payload = {\n            \"type\": \"invoice\",\n            \"amount\": 1000,\n            \"status\": \"pending\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/finance\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_finance_record(record_id):\n        resp = requests.delete(f\"{BASE_URL}/api/finance/{record_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete finance record with id {record_id}\")\n\n    def create_inventory_item():\n        payload = {\n            \"name\": \"Test Inventory Item\",\n            \"quantity\": 10,\n            \"location\": \"warehouse\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/inventory\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_inventory_item(item_id):\n        resp = requests.delete(f\"{BASE_URL}/api/inventory/{item_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete inventory item with id {item_id}\")\n\n    def create_supplier():\n        payload = {\n            \"name\": \"Test Supplier\",\n            \"contactEmail\": \"supplier@example.com\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/suppliers\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def delete_supplier(supplier_id):\n        resp = requests.delete(f\"{BASE_URL}/api/suppliers/{supplier_id}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Failed to delete supplier with id {supplier_id}\")\n\n    # Create test resources and clean up finally\n    customer_id = None\n    lead_id = None\n    job_id = None\n    staff_id = None\n    calendar_event_id = None\n    offer_id = None\n    finance_id = None\n    inventory_id = None\n    supplier_id = None\n\n    try:\n        # Create resources needed to verify CRM modules\n        customer_id = create_customer()\n        lead_id = create_lead()\n        job_id = create_job(customer_id)\n        staff_id = create_staff()\n        calendar_event_id = create_calendar_event()\n        offer_id = create_offer()\n        finance_id = create_finance_record()\n        inventory_id = create_inventory_item()\n        supplier_id = create_supplier()\n\n        # Wait briefly to allow real-time sync (assuming realtime mechanisms)\n        time.sleep(2)\n\n        # Test /api/customers GET returns created customer with accurate data\n        resp = requests.get(f\"{BASE_URL}/api/customers/{customer_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == customer_id\n        assert data[\"email\"] == \"testcustomer@example.com\"\n\n        # Test /api/leads GET returns created lead with AI scoring field\n        resp = requests.get(f\"{BASE_URL}/api/leads/{lead_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == lead_id\n        assert \"aiLeadScore\" in data or True  # If AI scoring is present\n\n        # Test /api/jobs GET returns the job with status and routing info\n        resp = requests.get(f\"{BASE_URL}/api/jobs/{job_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == job_id\n        assert data[\"status\"] == \"scheduled\"\n\n        # Test /api/staff GET returns the staff user with role and performance metrics\n        resp = requests.get(f\"{BASE_URL}/api/staff/{staff_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == staff_id\n        assert data[\"role\"] == \"employee\"\n\n        # Test /api/calendar/events GET returns the event data correctly\n        resp = requests.get(f\"{BASE_URL}/api/calendar/events/{calendar_event_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == calendar_event_id\n        assert \"start\" in data and \"end\" in data\n\n        # Test /api/offers GET returns the offer with correct status\n        resp = requests.get(f\"{BASE_URL}/api/offers/{offer_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == offer_id\n        assert data[\"status\"] == \"draft\"\n\n        # Test /api/finance GET returns the finance record with amount and status\n        resp = requests.get(f\"{BASE_URL}/api/finance/{finance_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == finance_id\n        assert data[\"amount\"] == 1000\n        assert data[\"status\"] == \"pending\"\n\n        # Test /api/inventory GET returns the inventory item with name and quantity\n        resp = requests.get(f\"{BASE_URL}/api/inventory/{inventory_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == inventory_id\n        assert data[\"quantity\"] == 10\n\n        # Test /api/suppliers GET returns the supplier with expected contact\n        resp = requests.get(f\"{BASE_URL}/api/suppliers/{supplier_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        data = resp.json()\n        assert data[\"id\"] == supplier_id\n        assert data[\"contactEmail\"] == \"supplier@example.com\"\n\n        # Test the CRM dashboard general endpoint for overview data and real-time updates\n        resp = requests.get(f\"{BASE_URL}/api/crm/dashboard\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200\n        dashboard_data = resp.json()\n        # Validate key modules data presence and counts\n        for key_module in [\"customers\", \"leads\", \"jobs\", \"staff\", \"calendar\", \"offers\", \"finance\", \"inventory\", \"suppliers\"]:\n            assert key_module in dashboard_data\n            assert isinstance(dashboard_data[key_module], dict) or isinstance(dashboard_data[key_module], list)\n            # If dict, expect keys like 'count'\n            if isinstance(dashboard_data[key_module], dict) and \"count\" in dashboard_data[key_module]:\n                assert dashboard_data[key_module][\"count\"] >= 0\n\n    finally:\n        # Cleanup resources to maintain test isolation\n        if supplier_id:\n            try:\n                delete_supplier(supplier_id)\n            except Exception:\n                pass\n        if inventory_id:\n            try:\n                delete_inventory_item(inventory_id)\n            except Exception:\n                pass\n        if finance_id:\n            try:\n                delete_finance_record(finance_id)\n            except Exception:\n                pass\n        if offer_id:\n            try:\n                delete_offer(offer_id)\n            except Exception:\n                pass\n        if calendar_event_id:\n            try:\n                delete_calendar_event(calendar_event_id)\n            except Exception:\n                pass\n        if staff_id:\n            try:\n                delete_staff(staff_id)\n            except Exception:\n                pass\n        if job_id:\n            try:\n                delete_job(job_id)\n            except Exception:\n                pass\n        if lead_id:\n            try:\n                delete_lead(lead_id)\n            except Exception:\n                pass\n        if customer_id:\n            try:\n                delete_customer(customer_id)\n            except Exception:\n                pass\n\n\ntest_crm_dashboard_and_modules_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 305, in <module>\n  File \"<string>\", line 167, in test_crm_dashboard_and_modules_functionality\n  File \"<string>\", line 25, in create_customer\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3001/api/customers\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.378Z",
    "modified": "2025-08-27T12:14:39.156Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "bd82f445-ca89-439c-bef6-a491b1ef97c8",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC007-ai integration accuracy and features",
    "description": "Test AI-powered features including customer service chatbot, lead scoring, price and route optimization, demand forecasting, and recruitment assistant Lowisa for accuracy and proper integration within the system.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_ai_integration_accuracy_and_features():\n    # Since the PRD does not specify explicit AI API request details,\n    # test main AI-related endpoints for expected behavior and accuracy indicators.\n    try:\n        # 1. Test customer service chatbot AI endpoint\n        chatbot_payload = {\n            \"channel\": \"web\",\n            \"message\": \"Hello, I need help with my booking.\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/ai/chatbot\", json=chatbot_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Chatbot API returned status {resp.status_code}\"\n        chatbot_response = resp.json()\n        assert \"reply\" in chatbot_response, \"Chatbot response missing 'reply'\"\n        assert isinstance(chatbot_response[\"reply\"], str) and len(chatbot_response[\"reply\"]) > 0, \"Chatbot reply invalid\"\n\n        # 2. Test AI lead scoring endpoint\n        lead_data = {\n            \"lead\": {\n                \"name\": \"Test Lead\",\n                \"email\": \"lead@example.com\",\n                \"source\": \"website\",\n                \"details\": \"Interested in moving services\"\n            }\n        }\n        resp = requests.post(f\"{BASE_URL}/api/ai/lead-scoring\", json=lead_data, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Lead scoring API returned status {resp.status_code}\"\n        lead_scoring = resp.json()\n        assert \"score\" in lead_scoring, \"Lead scoring missing 'score'\"\n        score_value = lead_scoring[\"score\"]\n        assert isinstance(score_value, (int, float)) and 0 <= score_value <= 1, \"Lead score out of expected range 0-1\"\n\n        # 3. Test price optimization endpoint\n        price_opt_payload = {\n            \"job\": {\n                \"service_type\": \"standard_move\",\n                \"distance_km\": 15,\n                \"volume_m3\": 20,\n                \"additional_services\": [\"packing\"]\n            }\n        }\n        resp = requests.post(f\"{BASE_URL}/api/ai/price-optimization\", json=price_opt_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Price optimization API returned status {resp.status_code}\"\n        price_opt = resp.json()\n        assert \"optimized_price\" in price_opt, \"Price optimization missing 'optimized_price'\"\n        assert isinstance(price_opt[\"optimized_price\"], (int, float)) and price_opt[\"optimized_price\"] > 0, \"Optimized price invalid\"\n\n        # 4. Test route optimization endpoint\n        route_opt_payload = {\n            \"jobs\": [\n                {\"job_id\": \"job1\", \"address\": \"123 Main St\", \"scheduled_time\": \"2025-09-01T08:00:00Z\"},\n                {\"job_id\": \"job2\", \"address\": \"456 Oak Ave\", \"scheduled_time\": \"2025-09-01T09:00:00Z\"},\n                {\"job_id\": \"job3\", \"address\": \"789 Pine Rd\", \"scheduled_time\": \"2025-09-01T10:30:00Z\"}\n            ],\n            \"start_location\": \"Depot Address\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/ai/route-optimization\", json=route_opt_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Route optimization API returned status {resp.status_code}\"\n        route_opt = resp.json()\n        assert \"optimized_route\" in route_opt and isinstance(route_opt[\"optimized_route\"], list), \"Route optimization missing or invalid 'optimized_route'\"\n        assert len(route_opt[\"optimized_route\"]) == len(route_opt_payload[\"jobs\"]), \"Optimized route length mismatch\"\n\n        # 5. Test demand forecasting endpoint\n        demand_forecast_payload = {\n            \"region\": \"Stockholm\",\n            \"time_horizon_days\": 30\n        }\n        resp = requests.post(f\"{BASE_URL}/api/ai/demand-forecasting\", json=demand_forecast_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Demand forecasting API returned status {resp.status_code}\"\n        demand_forecast = resp.json()\n        assert \"forecast\" in demand_forecast and isinstance(demand_forecast[\"forecast\"], list), \"Demand forecasting missing or invalid 'forecast'\"\n        for entry in demand_forecast[\"forecast\"]:\n            assert \"date\" in entry and \"expected_demand\" in entry, \"Forecast entry missing fields\"\n            assert isinstance(entry[\"expected_demand\"], (int, float)) and entry[\"expected_demand\"] >= 0, \"Expected demand invalid\"\n\n        # 6. Test recruitment assistant Lowisa endpoint\n        lowisa_payload = {\n            \"candidate_cv\": \"Experienced mover with 5 years in logistics and excellent customer service skills.\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/ai/recruitment/lowisa\", json=lowisa_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Lowisa recruitment AI returned status {resp.status_code}\"\n        lowisa_resp = resp.json()\n        assert \"screening_score\" in lowisa_resp, \"Lowisa response missing 'screening_score'\"\n        score = lowisa_resp[\"screening_score\"]\n        assert isinstance(score, (int, float)) and 0 <= score <= 100, \"Screening score out of range 0-100\"\n        assert \"recommendation\" in lowisa_resp and isinstance(lowisa_resp[\"recommendation\"], str), \"Lowisa missing or invalid recommendation\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    except AssertionError:\n        raise\n    except Exception as e:\n        assert False, f\"Unexpected error: {e}\"\n\ntest_ai_integration_accuracy_and_features()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 101, in <module>\n  File \"<string>\", line 18, in test_ai_integration_accuracy_and_features\nAssertionError: Chatbot API returned status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.384Z",
    "modified": "2025-08-27T12:14:43.402Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "463dfbeb-a50c-4800-9a9b-5ba3b2e711fa",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC008-automation workflows execution",
    "description": "Verify that automation workflows trigger correctly on booking confirmation, job completion, payment received, lead creation, and status changes, performing associated actions such as lead assignment, invoice generation, and follow-ups without errors.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef create_booking():\n    booking_payload = {\n        \"customerType\": \"individual\",\n        \"contactInformation\": {\n            \"name\": \"Test User\",\n            \"email\": \"testuser@example.com\",\n            \"phone\": \"+46700000000\"\n        },\n        \"serviceType\": \"standard_move\",\n        \"moveDetails\": {\n            \"fromAddress\": \"Testgatan 1, Stockholm\",\n            \"toAddress\": \"Exempelvägen 2, Stockholm\",\n            \"moveDate\": \"2025-09-10\"\n        },\n        \"inventory\": [\n            {\"item\": \"Box\", \"quantity\": 10},\n            {\"item\": \"Chair\", \"quantity\": 2}\n        ],\n        \"additionalServices\": [\"packing\", \"disassembly\"]\n    }\n    resp = requests.post(f\"{BASE_URL}/api/bookings\", json=booking_payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef confirm_booking(booking_id):\n    resp = requests.post(f\"{BASE_URL}/api/bookings/{booking_id}/confirm\", headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef create_job(booking_id):\n    job_payload = {\n        \"bookingId\": booking_id,\n        \"assignedStaffId\": None,\n        \"status\": \"pending\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/jobs\", json=job_payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef update_job_status(job_id, status):\n    resp = requests.put(f\"{BASE_URL}/api/jobs/{job_id}/status\", json={\"status\": status}, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef create_payment(booking_id, amount):\n    payment_payload = {\n        \"bookingId\": booking_id,\n        \"amount\": amount,\n        \"paymentMethod\": \"swish\",\n        \"status\": \"pending\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/finance/payments\", json=payment_payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef update_payment_status(payment_id, status):\n    resp = requests.put(f\"{BASE_URL}/api/finance/payments/{payment_id}/status\", json={\"status\": status}, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef create_lead(contact_info):\n    lead_payload = {\n        \"name\": contact_info[\"name\"],\n        \"email\": contact_info[\"email\"],\n        \"phone\": contact_info[\"phone\"],\n        \"source\": \"test_automation\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/leads\", json=lead_payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef update_booking_status(booking_id, status):\n    resp = requests.put(f\"{BASE_URL}/api/bookings/{booking_id}/status\", json={\"status\": status}, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef get_lead(lead_id):\n    resp = requests.get(f\"{BASE_URL}/api/leads/{lead_id}\", headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef get_invoice_by_booking(booking_id):\n    resp = requests.get(f\"{BASE_URL}/api/finance/invoices?bookingId={booking_id}\", headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef get_followups_by_lead(lead_id):\n    resp = requests.get(f\"{BASE_URL}/api/follow_ups?leadId={lead_id}\", headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef delete_booking(booking_id):\n    requests.delete(f\"{BASE_URL}/api/bookings/{booking_id}\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef delete_job(job_id):\n    requests.delete(f\"{BASE_URL}/api/jobs/{job_id}\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef delete_payment(payment_id):\n    requests.delete(f\"{BASE_URL}/api/finance/payments/{payment_id}\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef delete_lead(lead_id):\n    requests.delete(f\"{BASE_URL}/api/leads/{lead_id}\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef test_automation_workflows_execution():\n    booking_id = None\n    job_id = None\n    payment_id = None\n    lead_id = None\n\n    try:\n        # Create booking\n        booking = create_booking()\n        booking_id = booking.get(\"id\")\n        assert booking_id is not None\n\n        # Confirm booking triggers booking confirmation workflow including lead assignment etc.\n        confirmed = confirm_booking(booking_id)\n        assert confirmed.get(\"status\") == \"confirmed\"\n\n        # Allow some processing time for asynchronous workflows\n        time.sleep(3)\n\n        # Check that a lead is created or assigned upon booking confirmation\n        resp_leads = requests.get(f\"{BASE_URL}/api/leads?bookingId={booking_id}\", headers=HEADERS, timeout=TIMEOUT)\n        resp_leads.raise_for_status()\n        leads = resp_leads.json()\n        assert isinstance(leads, list)\n        assert len(leads) > 0\n        lead_id = leads[0].get(\"id\")\n        assert lead_id is not None\n\n        # Create a job linked to the booking to test job completion workflow\n        job = create_job(booking_id)\n        job_id = job.get(\"id\")\n        assert job_id is not None\n\n        # Update job status to completed to trigger job completion automation workflows\n        updated_job = update_job_status(job_id, \"completed\")\n        assert updated_job.get(\"status\") == \"completed\"\n\n        time.sleep(3)\n\n        # Check invoice generation triggered by job completion or booking confirmation\n        invoices = get_invoice_by_booking(booking_id)\n        assert isinstance(invoices, list)\n        assert len(invoices) > 0\n        invoice = invoices[0]\n        assert invoice.get(\"status\") in (\"pending\", \"paid\", \"unpaid\")\n\n        # Create a payment linked to the booking to test payment received workflow\n        payment = create_payment(booking_id, amount=invoice.get(\"totalAmount\", 1000))\n        payment_id = payment.get(\"id\")\n        assert payment_id is not None\n\n        # Update payment status to 'received' to trigger payment received workflows\n        updated_payment = update_payment_status(payment_id, \"received\")\n        assert updated_payment.get(\"status\") == \"received\"\n\n        time.sleep(3)\n\n        # Check follow-up actions triggered by payment received (e.g. follow-up emails)\n        followups = get_followups_by_lead(lead_id)\n        assert isinstance(followups, list)\n        # Expect at least one follow-up action created\n        assert len(followups) > 0\n\n        # Test lead creation and check automation on new lead creation\n        new_lead = create_lead({\"name\": \"Automation Lead\", \"email\": \"auto_lead@example.com\", \"phone\": \"+46701111222\"})\n        lead_id_new = new_lead.get(\"id\")\n        assert lead_id_new is not None\n\n        time.sleep(3)\n\n        # Confirm automation triggered on new lead creation such as assignment or notifications\n        lead_fetched = get_lead(lead_id_new)\n        assert lead_fetched.get(\"id\") == lead_id_new\n        # Check possible assignedStaff or leadScore auto-generated field\n        assert \"assignedStaffId\" in lead_fetched or \"leadScore\" in lead_fetched\n\n        # Test status change automation on booking\n        status_updated = update_booking_status(booking_id, \"in_progress\")\n        assert status_updated.get(\"status\") == \"in_progress\"\n\n        time.sleep(3)\n\n        # Validate automation effects on status change if any (could be lead re-assignment, notifications etc)\n        lead_after_status_change = get_lead(lead_id)\n        assert lead_after_status_change is not None\n\n    finally:\n        # Cleanup created resources\n        if lead_id:\n            try:\n                delete_lead(lead_id)\n            except Exception:\n                pass\n        if 'lead_id_new' in locals() and lead_id_new:\n            try:\n                delete_lead(lead_id_new)\n            except Exception:\n                pass\n        if payment_id:\n            try:\n                delete_payment(payment_id)\n            except Exception:\n                pass\n        if job_id:\n            try:\n                delete_job(job_id)\n            except Exception:\n                pass\n        if booking_id:\n            try:\n                delete_booking(booking_id)\n            except Exception:\n                pass\n\n\ntest_automation_workflows_execution()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 242, in <module>\n  File \"<string>\", line 135, in test_automation_workflows_execution\n  File \"<string>\", line 30, in create_booking\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3001/api/bookings\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.391Z",
    "modified": "2025-08-27T12:14:43.411Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "4c2e0549-1a70-4ca0-8a2b-cddeed6dcb23",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC009-security controls enforcement",
    "description": "Test security features including JWT and OTP authentication, BankID integration, input validation, data encryption, role-based access control, audit logging, and GDPR compliance.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n# Common headers\nHEADERS_JSON = {\"Content-Type\": \"application/json\"}\n\ndef test_security_controls_enforcement():\n    try:\n        # 1. Test JWT Authentication: simulate login and token issuance\n        login_payload = {\n            \"username\": \"testuser_security\",\n            \"password\": \"StrongPassword!23\"\n        }\n        login_resp = requests.post(f\"{BASE_URL}/api/auth/login\", json=login_payload, timeout=TIMEOUT, headers=HEADERS_JSON)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"JWT token missing in login response\"\n        jwt_token = login_data[\"token\"]\n        auth_headers = {\"Authorization\": f\"Bearer {jwt_token}\", **HEADERS_JSON}\n\n        # 2. Test OTP Authentication flow: request OTP and verify\n        otp_request_payload = {\"phone\": \"+46700000001\"}  # example test phone number\n        otp_req_resp = requests.post(f\"{BASE_URL}/api/auth/otp/request\", json=otp_request_payload, timeout=TIMEOUT, headers=HEADERS_JSON)\n        assert otp_req_resp.status_code == 200, f\"OTP request failed: {otp_req_resp.text}\"\n\n        # For test environment, simulate OTP retrieval (usually test OTP could be fixed or returned)\n        otp_code = \"123456\"  # Stub OTP code for testing\n\n        otp_verify_payload = {\"phone\": \"+46700000001\", \"otp\": otp_code}\n        otp_verify_resp = requests.post(f\"{BASE_URL}/api/auth/otp/verify\", json=otp_verify_payload, timeout=TIMEOUT, headers=HEADERS_JSON)\n        assert otp_verify_resp.status_code == 200, f\"OTP verify failed: {otp_verify_resp.text}\"\n        otp_data = otp_verify_resp.json()\n        assert \"token\" in otp_data, \"JWT token missing in OTP verify response\"\n        otp_jwt_token = otp_data[\"token\"]\n        otp_auth_headers = {\"Authorization\": f\"Bearer {otp_jwt_token}\", **HEADERS_JSON}\n\n        # 3. Test BankID integration: simulate BankID authentication initiation\n        bankid_init_payload = {\"personalNumber\": \"199001011234\"}  # Sample Swedish personal number\n        bankid_init_resp = requests.post(f\"{BASE_URL}/api/auth/bankid/initiate\", json=bankid_init_payload, timeout=TIMEOUT, headers=HEADERS_JSON)\n        assert bankid_init_resp.status_code == 200, f\"BankID initiation failed: {bankid_init_resp.text}\"\n        bankid_init_data = bankid_init_resp.json()\n        assert \"orderRef\" in bankid_init_data, \"orderRef missing in BankID initiation\"\n\n        order_ref = bankid_init_data[\"orderRef\"]\n\n        # Poll bankid status to simulate user completing BankID (mocked with timeout)\n        for _ in range(5):\n            bankid_status_resp = requests.get(f\"{BASE_URL}/api/auth/bankid/status/{order_ref}\", timeout=TIMEOUT, headers=HEADERS_JSON)\n            assert bankid_status_resp.status_code == 200, f\"BankID status fetch failed: {bankid_status_resp.text}\"\n            status_data = bankid_status_resp.json()\n            if status_data.get(\"status\") == \"complete\":\n                break\n            time.sleep(1)\n        else:\n            raise AssertionError(\"BankID authentication did not complete in expected time\")\n\n        # 4. Test input validation on user creation with invalid data (should fail)\n        invalid_user_payload = {\n            \"email\": \"invalid-email-format\",\n            \"password\": \"123\",  # weak password\n            \"username\": \"<script>alert('xss')</script>\"  # malicious input\n        }\n        invalid_resp = requests.post(f\"{BASE_URL}/api/users\", json=invalid_user_payload, timeout=TIMEOUT, headers=auth_headers)\n        assert invalid_resp.status_code == 400 or invalid_resp.status_code == 422, \"Input validation failed to reject invalid data\"\n\n        # 5. Create a user with valid data for role-based access test\n        valid_user_payload = {\n            \"username\": \"test_security_user\",\n            \"email\": \"securityuser@test.com\",\n            \"password\": \"StrongPassword!23\",\n            \"roles\": [\"user\"]\n        }\n        create_resp = requests.post(f\"{BASE_URL}/api/users\", json=valid_user_payload, timeout=TIMEOUT, headers=auth_headers)\n        assert create_resp.status_code == 201, f\"Failed to create test user: {create_resp.text}\"\n        user = create_resp.json()\n        user_id = user.get(\"id\")\n        assert user_id is not None, \"Created user ID missing\"\n\n        # 6. Attempt role-based access control: user with 'user' role should be denied admin-only endpoint\n        admin_only_headers = {**auth_headers}\n        # We must assume the token's permissions correspond to the user created or test token has 'user' role\n\n        admin_endpoint_resp = requests.get(f\"{BASE_URL}/api/admin/dashboard\", headers=admin_only_headers, timeout=TIMEOUT)\n        assert admin_endpoint_resp.status_code == 403 or admin_endpoint_resp.status_code == 401, \"Role-based access control failed to restrict access\"\n\n        # 7. Test audit logging presence by fetching audit logs for user actions (assuming audit logs API)\n        audit_logs_resp = requests.get(f\"{BASE_URL}/api/audit-logs?userId={user_id}\", headers=auth_headers, timeout=TIMEOUT)\n        assert audit_logs_resp.status_code == 200, f\"Failed to fetch audit logs: {audit_logs_resp.text}\"\n        audit_logs = audit_logs_resp.json()\n        assert isinstance(audit_logs, list), \"Audit logs response invalid\"\n        # Confirm at least one audit log entry related to the user creation\n        assert any(log.get(\"action\") == \"USER_CREATE\" and log.get(\"userId\") == user_id for log in audit_logs), \"Audit log for user creation missing\"\n\n        # 8. Test GDPR compliance: request user data export and delete\n        export_resp = requests.get(f\"{BASE_URL}/api/users/{user_id}/data-export\", headers=auth_headers, timeout=TIMEOUT)\n        assert export_resp.status_code == 200, f\"User data export failed: {export_resp.text}\"\n        # Data export content checks\n        export_data = export_resp.json()\n        assert \"user\" in export_data, \"Exported data incomplete\"\n\n        delete_resp = requests.delete(f\"{BASE_URL}/api/users/{user_id}\", headers=auth_headers, timeout=TIMEOUT)\n        assert delete_resp.status_code == 204, f\"User deletion failed: {delete_resp.text}\"\n\n        # 9. Test encryption: verify sensitive data retrieval is masked or encrypted\n        sensitive_resp = requests.get(f\"{BASE_URL}/api/users/{user_id}\", headers=auth_headers, timeout=TIMEOUT)\n        # Since user is deleted, expect 404\n        assert sensitive_resp.status_code == 404, \"Deleted user data still accessible, encryption/access control failed\"\n\n        # 10. Test that HTTPS enforcement is not bypassed - simulate by checking redirects or headers if available\n        # Since testing over HTTP local, assume HTTPS redirect header test not applicable in local test\n\n        # 11. Test CSRF and XSS protections by sending malicious payloads on a form endpoint and expect rejection or sanitization\n        xss_payload = {\n            \"note\": \"<script>alert('XSS')</script>\"\n        }\n        note_resp = requests.post(f\"{BASE_URL}/api/notes\", json=xss_payload, headers=auth_headers, timeout=TIMEOUT)\n        # Expect validation error or sanitized output\n        assert note_resp.status_code in (200, 201, 400, 422), \"Unexpected status for XSS payload\"\n        if note_resp.status_code in (200,201):\n            # Check response sanitized\n            note_content = note_resp.json().get(\"note\", \"\")\n            assert \"<script>\" not in note_content.lower(), \"XSS protection failed, script tag present\"\n\n    finally:\n        # Cleanup: delete created user if still exists\n        try:\n            # Use admin or JWT token for cleanup\n            if 'user_id' in locals():\n                requests.delete(f\"{BASE_URL}/api/users/{user_id}\", headers=auth_headers, timeout=TIMEOUT)\n        except Exception:\n            pass\n\n\ntest_security_controls_enforcement()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 137, in <module>\n  File \"<string>\", line 18, in test_security_controls_enforcement\nAssertionError: Login failed: Too many requests\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.398Z",
    "modified": "2025-08-27T12:14:43.404Z"
  },
  {
    "projectId": "9f54c4e9-0f8b-4fef-9e0b-e19ee1b7de3f",
    "testId": "7b2e634d-32eb-4eec-8eb5-39e20e321211",
    "userId": "441824b8-4061-705b-7a05-fc408b05d396",
    "title": "TC010-pwa features and offline support",
    "description": "Validate PWA capabilities such as offline functionality with service worker caching, push notifications, app-like experience across devices, and responsive, touch-optimized design.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_pwa_features_and_offline_support():\n    # As PWA features involve frontend/browser functionalities (service workers, manifest, push notifications, responsive UI),\n    # we test the existence and correctness of related assets and API endpoints that support these features.\n    # This test will:\n    # 1. Check that the service worker file is served correctly with proper headers.\n    # 2. Verify the app manifest is available and has expected fields.\n    # 3. Check push notification subscription API endpoint responds as expected.\n    # 4. Validate responsive metadata via the homepage headers or API response (limited to API testing).\n    \n    # 1. Check Service Worker script availability and headers\n    sw_url = f\"{BASE_URL}/service-worker.js\"\n    try:\n        sw_response = requests.get(sw_url, timeout=TIMEOUT)\n        assert sw_response.status_code == 200, f\"Service Worker file not found at {sw_url}.\"\n        content_type = sw_response.headers.get(\"Content-Type\", \"\")\n        assert \"javascript\" in content_type.lower(), f\"Unexpected Content-Type for service-worker.js: {content_type}\"\n    except requests.RequestException as e:\n        assert False, f\"Request to service worker file failed: {e}\"\n\n    # 2. Check Web App Manifest availability and contents\n    manifest_url = f\"{BASE_URL}/manifest.json\"\n    try:\n        manifest_response = requests.get(manifest_url, timeout=TIMEOUT)\n        assert manifest_response.status_code == 200, f\"Manifest file not found at {manifest_url}.\"\n        manifest_json = manifest_response.json()\n        # Validate essential manifest fields for app-like experience\n        required_fields = [\"name\", \"short_name\", \"start_url\", \"display\", \"icons\"]\n        for field in required_fields:\n            assert field in manifest_json, f\"Manifest missing required field: {field}\"\n        # Validate display mode supports app-like experience\n        assert manifest_json.get(\"display\") in [\"standalone\", \"fullscreen\", \"minimal-ui\"], (\n            f\"Manifest display mode is not app-like: {manifest_json.get('display')}\"\n        )\n        # Check icons array is not empty\n        icons = manifest_json.get(\"icons\")\n        assert isinstance(icons, list) and len(icons) > 0, \"Manifest icons array is empty or missing\"\n    except requests.RequestException as e:\n        assert False, f\"Request to manifest file failed: {e}\"\n    except ValueError:\n        assert False, \"Manifest response is not a valid JSON\"\n\n    # 3. Test Push Notifications subscription endpoint (simulate a subscribe request)\n    # Assuming an endpoint exists: /api/notifications/subscribe accepting POST\n    push_subscribe_url = f\"{BASE_URL}/api/notifications/subscribe\"\n    fake_subscription_payload = {\n        \"endpoint\": \"https://fcm.googleapis.com/fcm/send/fake-subscription-id\",\n        \"keys\": {\n            \"p256dh\": \"fake-p256dh-key\",\n            \"auth\": \"fake-auth-key\"\n        }\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n    try:\n        push_response = requests.post(push_subscribe_url, json=fake_subscription_payload, headers=headers, timeout=TIMEOUT)\n        # It's possible push subscription API requires auth or may reject fake payload;\n        # accept both 200 (or 201) or 400+ with proper JSON error message as valid server handling.\n        assert push_response.status_code in [200, 201, 400, 422], (\n            f\"Unexpected push subscription API response status: {push_response.status_code}\"\n        )\n        # If JSON response, check structure for clarity\n        try:\n            data = push_response.json()\n            assert isinstance(data, dict), \"Push subscription response is not a JSON object\"\n            # If error, check error message exists; if success, expect confirmation field\n            if push_response.status_code in [400, 422]:\n                assert \"error\" in data or \"message\" in data, \"Error response lacks error/message field\"\n            else:\n                assert \"success\" in data or \"subscriptionId\" in data or data == {}, \"Success response missing expected confirmation\"\n        except ValueError:\n            # Non-JSON responses acceptable if status is 200 or 201\n            if push_response.status_code in [200, 201]:\n                pass\n            else:\n                assert False, \"Push subscription response is not valid JSON\"\n    except requests.RequestException as e:\n        assert False, f\"Request to push subscription endpoint failed: {e}\"\n\n    # 4. Check homepage headers for responsive and caching controls that help PWA experience\n    home_url = f\"{BASE_URL}/\"\n    try:\n        home_resp = requests.get(home_url, timeout=TIMEOUT)\n        assert home_resp.status_code == 200, \"Homepage not accessible\"\n        # Check cache-control header presence for offline support caching or service worker fallback\n        cache_control = home_resp.headers.get(\"Cache-Control\") or home_resp.headers.get(\"cache-control\")\n        assert cache_control is not None, \"Homepage missing Cache-Control header for offline caching\"\n        # Validate viewport meta tag presence by fetching html content\n        html_text = home_resp.text\n        assert 'name=\"viewport\"' in html_text or \"viewport\" in html_text.lower(), \"Homepage missing viewport meta tag for responsive design\"\n        # Check for touch optimization meta tags or CSS media queries presence is not possible at API level,\n        # but at least confirm the document mentions 'touch' or similar (basic heuristic)\n        assert \"touch\" in html_text.lower() or \"mobile\" in html_text.lower(), \"Homepage seems not touch optimized/responsive\"\n    except requests.RequestException as e:\n        assert False, f\"Request to homepage failed: {e}\"\n\ntest_pwa_features_and_offline_support()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 101, in <module>\n  File \"<string>\", line 20, in test_pwa_features_and_offline_support\nAssertionError: Service Worker file not found at http://localhost:3001/service-worker.js.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-27T12:13:34.404Z",
    "modified": "2025-08-27T12:14:45.297Z"
  }
]
