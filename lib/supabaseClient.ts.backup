import { createClient } from "@supabase/supabase-js"
import type { Database } from "../types/supabase"
import { validateEnvVars } from "./env-check"

// Validera miljövariabler vid import
const envStatus = validateEnvVars()
if (!envStatus.supabaseConfigured) {
  console.error("Supabase miljövariabler saknas. Kontrollera .env.local filen.")
}
if (!envStatus.sendgridConfigured || !envStatus.twilioConfigured) {
  console.warn("Notifieringsfunktioner (e-post/SMS) kanske inte fungerar på grund av saknade miljövariabler.")
}

// Kontrollera att miljövariabler finns
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

// Singleton pattern för client-side Supabase-klient
let clientSupabaseInstance: ReturnType<typeof createClient<Database>> | null = null

// Exportera en direkt användbar klient-instans för enklare användning i komponenter
export const supabase = createClient<Database>(
  supabaseUrl || "",
  supabaseKey || ""
)

export const createClientSupabaseClient = () => {
  if (clientSupabaseInstance) return clientSupabaseInstance

  clientSupabaseInstance = createClient<Database>(supabaseUrl || "", supabaseKey || "")
  return clientSupabaseInstance
}

// LÄGG TILL: Alias för att matcha auth-helpers-nextjs API namn
export const createClientComponentClient = createClientSupabaseClient

// Server-side Supabase-klient med admin-rättigheter
export const createServerSupabaseClient = () => {
  const serverSupabaseUrl = process.env.SUPABASE_URL
  const serverSupabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY
  
  if (!serverSupabaseUrl || !serverSupabaseKey) {
    console.error("Supabase server miljövariabler saknas. Kontrollera .env.local filen.")
  }
  
  return createClient<Database>(serverSupabaseUrl || "", serverSupabaseKey || "")
}

/**
 * Enkel funktion för att rensa ID-strängar utan strikt validering
 * @param id ID-sträng att rensa
 * @returns Rensat ID utan citattecken och trimmat
 */
function sanitizeId(id: string): string {
  if (!id) return '';
  return id.replace(/['"]/g, '').trim();
}

// Hjälpfunktioner för att hantera offerter
export const quoteService = {
  async createQuote(quoteData: any) {
    const supabase = createServerSupabaseClient()

    // Skapa kund om den inte finns
    let customerId = quoteData.customerId

    if (!customerId && quoteData.customerInfo) {
      const { data: customer, error: customerError } = await supabase
        .from("customers")
        .insert({
          name: quoteData.customerInfo.name,
          email: quoteData.customerInfo.email,
          phone: quoteData.customerInfo.phone,
          customer_type: quoteData.customerType || "Privat",
          notes: JSON.stringify({
            address: quoteData.customerInfo.address,
          }),
        })
        .select("id")
        .single()

      if (customerError) {
        console.error("Fel vid skapande av kund:", customerError)
        throw new Error(`Kunde inte skapa kund: ${customerError.message}`)
      }

      customerId = customer.id
    }

    // Skapa offert
    const { data: quote, error: quoteError } = await supabase
      .from("quotes")
      .insert({
        customer_id: customerId,
        services: quoteData.services || [],
        value: quoteData.totalPrice || 0,
        status: "Väntande",
        valid_until: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 dagar
        details: JSON.stringify({
          moveDetails: quoteData.moveDetails,
          inventory: quoteData.inventory,
          additionalServices: quoteData.additionalServices,
        }),
      })
      .select()
      .single()

    if (quoteError) {
      console.error("Fel vid skapande av offert:", quoteError)
      throw new Error(`Kunde inte skapa offert: ${quoteError.message}`)
    }

    return quote
  },

  async getQuote(id: string) {
    // ÄNDRAT: Använd createClientSupabaseClient istället för createServerSupabaseClient
    // för att undvika problem med server-side credentials på klientens sida
    const supabase = createClientSupabaseClient()

    try {
      // Rensa ID:t från oönskade tecken
      const cleanId = id.replace(/[^a-zA-Z0-9-]/g, '');
      
      console.log("Söker offert med ID:", cleanId);
      
      // Steg 1: Försök exakt matchning med ID
      let { data: quote, error } = await supabase
        .from("quotes")
        .select(`
          *,
          customers (*)
        `)
        .eq('id', cleanId)  // Använd exakt matchning istället för ilike
        .maybeSingle();
        
      if (quote) {
        console.log("Hittade offert med ID:", quote.id);
      } else {
        console.log("Exakt matchning misslyckades:", error?.message || "Inga resultat");
      }
        
      // Om inga resultat hittades, prova med textmatchning
      if (!quote && cleanId.length >= 4) {
        console.log("Försöker textmatchning med:", cleanId);
        
        // Steg 2: Prova textmatchning
        const { data: flexQuote, error: flexError } = await supabase
          .from("quotes")
          .select(`
            *,
            customers (*)
          `)
          .filter('id', 'ilike', `%${cleanId}%`)
          .maybeSingle();
          
        if (flexQuote) {
          quote = flexQuote;
          console.log("Hittade offert med textmatchning:", quote.id);
        } else {
          console.log("Textmatchning misslyckades:", flexError?.message || "Inga resultat");
        }
      }
      
      // Steg 3: Fallback till senaste offert om ingen matchning hittades
      if (!quote) {
        console.log("Alla matchningsförsök misslyckades, använder fallback");
        
        const { data: fallbackQuote, error: fallbackError } = await supabase
          .from("quotes")
          .select(`
            *,
            customers (*)
          `)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();
          
        if (fallbackQuote) {
          console.log("Använder senaste offerten som fallback:", fallbackQuote.id);
          // Markera denna som en fallback för UI
          fallbackQuote.isFallback = true;
          quote = fallbackQuote;
        } else {
          console.log("Kunde inte hitta någon fallback-offert:", fallbackError?.message);
          return null; // Om ingen fallback hittas, returnera null
        }
      }

      // Tolka details-fältet om det finns och är en JSON-sträng
      if (quote.details && typeof quote.details === 'string') {
        try {
          quote.details = JSON.parse(quote.details);
        } catch (jsonError) {
          console.error("Fel vid parsning av details-JSON:", jsonError);
          // Sätt details till tomt objekt istället för att kasta fel
          quote.details = {};
        }
      } else if (!quote.details) {
        quote.details = {};
      }

      // Hantera services som ett JSON-array i quotes-tabellen
      let transformedServices = []
      
      if (quote.services) {
        if (typeof quote.services === 'string') {
          // Om services är en JSON-sträng, parsa den
          try {
            quote.services = JSON.parse(quote.services);
          } catch (error) {
            console.error("Fel vid parsning av services-JSON:", error);
            quote.services = [];
          }
        }

        // Transformera services till objekt med id, name och price
        if (Array.isArray(quote.services)) {
          transformedServices = quote.services.map((service: any, index: number) => {
            // Om service är ett objekt med name och price, använd det
            if (typeof service === 'object' && service !== null) {
              return {
                id: service.id || `service-${index}`,
                name: service.name || 'Okänd tjänst',
                price: service.price || 0
              }
            } 
            // Om service är en sträng, skapa ett objekt
            else if (typeof service === 'string') {
              // Baserat på servicens namn, sätt ett standardpris
              let price = 0;
              if (service.toLowerCase().includes('flytt')) {
                price = 2700;
              } else if (service.toLowerCase().includes('pack')) {
                price = 700;
              } else if (service.toLowerCase().includes('städ')) {
                price = 2500;
              }
              
              return {
                id: `service-${index}`,
                name: service,
                price: price
              }
            }
            // Fallback för andra datatyper
            return {
              id: `service-${index}`,
              name: 'Okänd tjänst',
              price: 0
            }
          })
        }
      }
      
      // Ersätt quote.services med de transformerade tjänsterna
      quote.services = transformedServices;

      return quote;
    } catch (error) {
      console.error("Fel vid hämtning av offert:", error);
      
      // Fler detaljer för felsökning
      if (error instanceof Error) {
        console.error("Error message:", error.message);
        console.error("Error stack:", error.stack);
      }
      
      throw error;
    }
  },
}

// Hjälpfunktioner för att hantera bokningar
export const bookingService = {
  async createBooking(bookingData: any) {
    const supabase = createServerSupabaseClient()

    // Skapa kund om den inte finns
    let customerId = bookingData.customerId

    if (!customerId && bookingData.customerInfo) {
      const { data: customer, error: customerError } = await supabase
        .from("customers")
        .insert({
          name: bookingData.customerInfo.name,
          email: bookingData.customerInfo.email,
          phone: bookingData.customerInfo.phone,
          customer_type: bookingData.customerType || "Privat",
          notes: bookingData.customerInfo.notes || null,
        })
        .select("id")
        .single()

      if (customerError) {
        console.error("Fel vid skapande av kund:", customerError)
        throw new Error(`Kunde inte skapa kund: ${customerError.message}`)
      }

      customerId = customer.id
    }

    // Skapa bokning
    const { data: booking, error: bookingError } = await supabase
      .from("bookings")
      .insert({
        customer_id: customerId,
        service_type: bookingData.serviceType,
        service_types: bookingData.serviceTypes || [],
        move_date: bookingData.moveDate || null,
        move_time: bookingData.moveTime || null,
        start_address: bookingData.startAddress || null,
        end_address: bookingData.endAddress || null,
        status: bookingData.status || "pending",
        total_price: bookingData.totalPrice || 0,
        created_at: new Date().toISOString(),
      })
      .select()
      .single()

    if (bookingError) {
      console.error("Fel vid skapande av bokning:", bookingError)
      throw new Error(`Kunde inte skapa bokning: ${bookingError.message}`)
    }

    return booking
  },

  async getBooking(id: string) {
    const supabase = createServerSupabaseClient()

    const { data: booking, error } = await supabase
      .from("bookings")
      .select(`
        *,
        customers (*)
      `)
      .eq("id", id)
      .single()

    if (error) {
      console.error("Fel vid hämtning av bokning:", error)
      throw new Error(`Kunde inte hämta bokning: ${error.message}`)
    }

    return booking
  },

  async updateBookingStatus(id: string, status: string) {
    const supabase = createServerSupabaseClient()

    const { data, error } = await supabase
      .from("bookings")
      .update({ 
        status: status,
        updated_at: new Date().toISOString()
      })
      .eq("id", id)
      .select()
      .single()

    if (error) {
      console.error("Fel vid uppdatering av bokningsstatus:", error)
      throw new Error(`Kunde inte uppdatera bokningsstatus: ${error.message}`)
    }

    return data
  }
}
