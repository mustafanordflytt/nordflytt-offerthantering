import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { LeadParser } from '@/lib/lead-parser'
import { validateCRMAuth } from '@/lib/auth/validate-crm-auth'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
const supabase = createClient(supabaseUrl, supabaseServiceKey)

export async function POST(request: NextRequest) {
  try {
    // Validate CRM authentication
    const authResult = await validateCRMAuth(request)
    if (!authResult.isValid || !authResult.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { leadText, leadId } = await request.json()

    if (!leadText && !leadId) {
      return NextResponse.json(
        { error: 'Either leadText or leadId is required' },
        { status: 400 }
      )
    }

    let textToParse = leadText

    // If leadId provided, fetch lead from database
    if (leadId && !leadText) {
      const { data: lead, error } = await supabase
        .from('leads')
        .select('*')
        .eq('id', leadId)
        .single()

      if (error || !lead) {
        return NextResponse.json(
          { error: 'Lead not found' },
          { status: 404 }
        )
      }

      // Use lead notes or metadata as text to parse
      textToParse = lead.notes || JSON.stringify(lead.metadata || {})
    }

    // Parse lead
    const parser = new LeadParser()
    const parsedLead = parser.parse(textToParse)
    const completeLead = parser.fillWithDefaults(parsedLead)

    // Calculate distance if we have addresses
    let calculatedDistance = 10 // Default 10 km
    if (completeLead.fromAddress && completeLead.toAddress) {
      try {
        // In production, use Google Maps API
        // For now, use a simple estimation based on postcodes
        const fromPostcode = parseInt(completeLead.fromPostcode || '10000')
        const toPostcode = parseInt(completeLead.toPostcode || '10000')
        calculatedDistance = Math.abs(fromPostcode - toPostcode) / 100 // Very rough estimate
        calculatedDistance = Math.max(5, Math.min(calculatedDistance, 500)) // Between 5-500 km
      } catch (err) {
        console.error('Distance calculation error:', err)
      }
    }

    // Prepare booking data matching the submit-booking API format
    const bookingData = {
      // Customer info
      customerName: completeLead.customerName,
      customerEmail: completeLead.email,
      customerPhone: completeLead.phone,
      customerType: 'private',

      // Service info
      serviceType: 'moving',
      serviceTypes: ['moving'],
      
      // Move details
      moveDate: completeLead.moveDate,
      moveTime: '08:00-10:00',
      
      // Addresses
      startAddress: completeLead.fromAddress,
      startPostcode: completeLead.fromPostcode,
      startCity: completeLead.fromCity || '',
      startFloor: completeLead.fromFloor.toString(),
      
      endAddress: completeLead.toAddress,
      endPostcode: completeLead.toPostcode,
      endCity: completeLead.toCity || '',
      endFloor: completeLead.toFloor.toString(),
      
      // Property details
      apartmentSize: completeLead.squareMeters.toString(),
      numberOfRooms: completeLead.rooms?.toString() || '2',
      
      // Access info
      hasElevatorStart: completeLead.hasElevatorFrom,
      hasElevatorEnd: completeLead.hasElevatorTo,
      parkingDistanceStart: completeLead.parkingDistanceFrom.toString(),
      parkingDistanceEnd: completeLead.parkingDistanceTo.toString(),
      
      // Volume and distance
      estimatedVolume: completeLead.estimatedVolume,
      calculatedDistance,
      
      // Additional services
      additionalServices: [
        ...(completeLead.packingService ? ['Packning'] : []),
        ...(completeLead.cleaningService ? ['Städning'] : [])
      ],
      
      // Notes
      additionalInfo: completeLead.additionalInfo || `Automatiskt genererad från lead (${completeLead.leadSource || 'email'})`,
      
      // Lead tracking
      leadSource: completeLead.leadSource,
      autoGenerated: true,
      confidence: parsedLead.squareMeters ? 'high' : 'medium'
    }

    // Call submit-booking API directly using internal function
    try {
      // Import the handler directly to avoid network call
      const submitBookingModule = await import('../../../submit-booking/route')
      
      // Create a fake request for the internal call
      const internalRequest = new NextRequest(
        new URL('/api/submit-booking', request.url),
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': request.headers.get('Authorization') || ''
          },
          body: JSON.stringify(bookingData)
        }
      )
      
      const bookingResponse = await submitBookingModule.POST(internalRequest)

      const bookingResult = await bookingResponse.json()
      
      if (!bookingResult.success) {
        throw new Error(bookingResult.error || 'Failed to create booking')
      }

      // Update lead with offer_id if leadId provided
      if (leadId) {
        await supabase
          .from('leads')
          .update({ 
            offer_id: bookingResult.id,
            status: 'proposal',
            updated_at: new Date().toISOString(),
            updated_by: authResult.user.id
          })
          .eq('id', leadId)
      }

      // Log the automatic processing
      await supabase
        .from('lead_activities')
        .insert({
          lead_id: leadId || null,
          type: 'note',
          title: 'Automatisk offert skapad',
          description: `Offert ${bookingResult.bookingNumber} skapades automatiskt från lead-data`,
          completed: true,
          created_by: authResult.user.id
        })

      return NextResponse.json({
        success: true,
        booking: bookingResult,
        parsedData: completeLead,
        confidence: bookingData.confidence,
        message: 'Offer created successfully from lead'
      })
    } catch (bookingError: any) {
      console.error('Internal booking creation error:', bookingError)
      throw new Error('Failed to create booking: ' + bookingError.message)
    }

  } catch (error: any) {
    console.error('Lead processing error:', error)
    return NextResponse.json({
      success: false,
      error: 'Failed to process lead',
      details: error.message
    }, { status: 500 })
  }
}

// Batch processing endpoint
export async function PUT(request: NextRequest) {
  try {
    // Validate CRM authentication
    const authResult = await validateCRMAuth(request)
    if (!authResult.isValid || !authResult.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { leadIds, autoProcess } = await request.json()

    if (!Array.isArray(leadIds) || leadIds.length === 0) {
      return NextResponse.json(
        { error: 'leadIds array is required' },
        { status: 400 }
      )
    }

    // Fetch all leads
    const { data: leads, error } = await supabase
      .from('leads')
      .select('*')
      .in('id', leadIds)
      .is('offer_id', null) // Only process leads without offers

    if (error || !leads || leads.length === 0) {
      return NextResponse.json(
        { error: 'No processable leads found' },
        { status: 404 }
      )
    }

    const results = []
    
    for (const lead of leads) {
      try {
        // Process each lead
        const response = await POST(
          new NextRequest(request.url, {
            method: 'POST',
            headers: request.headers,
            body: JSON.stringify({
              leadId: lead.id,
              leadText: lead.notes || JSON.stringify(lead.metadata || {})
            })
          })
        )

        const result = await response.json()
        results.push({
          leadId: lead.id,
          success: result.success,
          bookingNumber: result.booking?.bookingNumber,
          error: result.error
        })
      } catch (err: any) {
        results.push({
          leadId: lead.id,
          success: false,
          error: err.message
        })
      }
    }

    const successCount = results.filter(r => r.success).length
    const failureCount = results.filter(r => !r.success).length

    return NextResponse.json({
      success: true,
      processed: results.length,
      successful: successCount,
      failed: failureCount,
      results
    })

  } catch (error: any) {
    console.error('Batch processing error:', error)
    return NextResponse.json({
      success: false,
      error: 'Failed to process leads',
      details: error.message
    }, { status: 500 })
  }
}