// =============================================================================
// NORDFLYTT AI CHATBOT - REVENUE ATTRIBUTION API
// Track and analyze revenue generated by chatbot conversations
// =============================================================================

import { NextRequest, NextResponse } from 'next/server';

/**
 * GET /api/chat/revenue/attribution
 * Get revenue attribution data for chatbot conversations
 */
export async function GET(request: NextRequest) {
  try {
    console.log('💰 Revenue attribution analysis requested');
    
    const url = new URL(request.url);
    const period = url.searchParams.get('period') || 'today'; // today, week, month
    const detailed = url.searchParams.get('detailed') === 'true';
    const includeForecasting = url.searchParams.get('forecasting') === 'true';
    
    // Get revenue data based on period
    const revenueData = await getRevenueAttributionData(period);
    
    // Get channel breakdown
    const channelBreakdown = await getChannelRevenueBreakdown(period);
    
    // Get top performing conversations
    const topConversations = await getTopRevenueConversations(period);
    
    // Calculate forecasting if requested
    const forecasting = includeForecasting ? await generateRevenueForecasting() : null;

    console.log('✅ Revenue attribution analysis completed', {
      period,
      totalRevenue: revenueData.daily_revenue,
      conversionsCount: revenueData.upsells_count,
      avgRevenuePerConversation: Math.round(revenueData.daily_revenue / Math.max(revenueData.total_conversations, 1))
    });

    const response = {
      success: true,
      period: period,
      timestamp: new Date().toISOString(),
      
      // Core metrics
      daily_revenue: revenueData.daily_revenue,
      upsells_count: revenueData.upsells_count,
      cost_savings: revenueData.cost_savings,
      conversion_rate: revenueData.conversion_rate,
      
      // Business intelligence
      revenue_by_channel: channelBreakdown,
      top_conversations: topConversations,
      
      // Performance metrics
      performance: {
        total_conversations: revenueData.total_conversations,
        converted_conversations: revenueData.converted_conversations,
        average_revenue_per_conversation: Math.round(revenueData.daily_revenue / Math.max(revenueData.total_conversations, 1)),
        average_conversion_time_hours: revenueData.average_conversion_time,
        customer_satisfaction_impact: revenueData.satisfaction_impact
      },
      
      // Comparative analysis
      comparison: {
        vs_yesterday: revenueData.growth_vs_yesterday,
        vs_last_week: revenueData.growth_vs_last_week,
        vs_human_agents: revenueData.vs_human_performance
      }
    };

    if (detailed) {
      response.detailed_breakdown = await getDetailedRevenueBreakdown(period);
    }

    if (forecasting) {
      response.forecasting = forecasting;
    }

    return NextResponse.json(response);

  } catch (error) {
    console.error('❌ Revenue attribution analysis failed:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to analyze revenue attribution',
      details: error.message
    }, { status: 500 });
  }
}

/**
 * POST /api/chat/revenue/attribution
 * Record new revenue attribution from chatbot conversation
 */
export async function POST(request: NextRequest) {
  try {
    console.log('💰 Recording new revenue attribution');
    
    const body = await request.json();
    const {
      conversation_id,
      customer_id,
      interaction_type,
      revenue_amount,
      attribution_confidence,
      conversion_data
    } = body;

    // Validate required fields
    if (!conversation_id || !interaction_type || !revenue_amount) {
      return NextResponse.json({
        success: false,
        error: 'conversation_id, interaction_type, and revenue_amount are required'
      }, { status: 400 });
    }

    // Record revenue attribution
    const attribution = await recordRevenueAttribution({
      conversation_id,
      customer_id,
      interaction_type,
      revenue_amount,
      attribution_confidence: attribution_confidence || 0.8,
      conversion_data: conversion_data || {},
      timestamp: new Date().toISOString()
    });

    console.log('✅ Revenue attribution recorded', {
      attributionId: attribution.id,
      revenue: revenue_amount,
      confidence: attribution_confidence
    });

    return NextResponse.json({
      success: true,
      attribution_id: attribution.id,
      message: 'Revenue attribution recorded successfully'
    });

  } catch (error) {
    console.error('❌ Failed to record revenue attribution:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to record revenue attribution',
      details: error.message
    }, { status: 500 });
  }
}

// =============================================================================
// REVENUE DATA GENERATION AND ANALYSIS
// =============================================================================

async function getRevenueAttributionData(period: string) {
  // Mock revenue data - replace with actual database queries
  const baseRevenue = period === 'today' ? 24500 : 
                     period === 'week' ? 156000 : 
                     period === 'month' ? 680000 : 24500;

  const variation = Math.random() * 0.2 - 0.1; // ±10% variation
  const actualRevenue = Math.round(baseRevenue * (1 + variation));

  return {
    daily_revenue: actualRevenue,
    upsells_count: Math.floor(actualRevenue / 2500), // Average 2500 kr per upsell
    cost_savings: Math.round(actualRevenue * 0.32), // 32% cost savings vs human agents
    conversion_rate: 0.28 + Math.random() * 0.15, // 28-43% conversion rate
    total_conversations: Math.floor(actualRevenue / 850), // Average 850 kr revenue per conversation
    converted_conversations: Math.floor(actualRevenue / 2800), // Higher revenue for converted
    average_conversion_time: 2.3 + Math.random() * 1.5, // 2.3-3.8 hours
    satisfaction_impact: 4.6 + Math.random() * 0.3, // Customer satisfaction improvement
    
    // Growth metrics
    growth_vs_yesterday: 0.12 + Math.random() * 0.16, // 12-28% growth
    growth_vs_last_week: 0.08 + Math.random() * 0.14, // 8-22% growth
    
    // Comparison with human agents
    vs_human_performance: {
      revenue_per_hour: 2850, // AI vs human agent hourly revenue
      cost_efficiency: 0.68, // 68% more cost efficient
      response_speed: 0.92, // 92% faster responses
      availability: 1.0 // 100% uptime vs human availability
    }
  };
}

async function getChannelRevenueBreakdown(period: string) {
  const channels = ['website', 'whatsapp', 'email', 'facebook', 'google_reviews'];
  const breakdown = [];

  for (const channel of channels) {
    const revenue = Math.floor(Math.random() * 8000) + 2000;
    const conversations = Math.floor(revenue / (600 + Math.random() * 400));
    
    breakdown.push({
      channel: channel,
      revenue: revenue,
      conversations: conversations,
      conversion_rate: 0.2 + Math.random() * 0.3,
      average_revenue_per_conversation: Math.round(revenue / conversations),
      growth_rate: -0.05 + Math.random() * 0.25, // -5% to +20% growth
      customer_satisfaction: 4.0 + Math.random() * 1.0
    });
  }

  return breakdown.sort((a, b) => b.revenue - a.revenue);
}

async function getTopRevenueConversations(period: string) {
  const conversations = [];
  
  const interactionTypes = [
    { type: 'new_booking', label: 'New Booking', avg_revenue: 12000 },
    { type: 'upsell_packing', label: 'Packing Service Upsell', avg_revenue: 3500 },
    { type: 'upsell_insurance', label: 'Insurance Upsell', avg_revenue: 800 },
    { type: 'upsell_storage', label: 'Storage Service Upsell', avg_revenue: 2200 },
    { type: 'retention_offer', label: 'Customer Retention', avg_revenue: 8500 }
  ];

  for (let i = 0; i < 10; i++) {
    const interactionType = interactionTypes[Math.floor(Math.random() * interactionTypes.length)];
    const variation = 0.7 + Math.random() * 0.6; // ±30% variation
    const revenue = Math.round(interactionType.avg_revenue * variation);
    
    conversations.push({
      conversation_id: 1000 + i,
      customer_name: `Customer ${Math.floor(Math.random() * 100) + 1}`,
      interaction_type: interactionType.type,
      interaction_label: interactionType.label,
      revenue_attributed: revenue,
      attribution_confidence: 0.75 + Math.random() * 0.25,
      conversion_time_hours: 1 + Math.random() * 4,
      channel: ['website', 'whatsapp', 'email'][Math.floor(Math.random() * 3)],
      timestamp: new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000).toISOString(),
      customer_satisfaction: 4 + Math.random() * 1,
      ai_contribution: 0.8 + Math.random() * 0.2
    });
  }

  return conversations.sort((a, b) => b.revenue_attributed - a.revenue_attributed);
}

async function generateRevenueForecasting() {
  const currentTrend = 0.15; // 15% growth trend
  const seasonality = Math.sin(Date.now() / (1000 * 60 * 60 * 24 * 365.25) * 2 * Math.PI) * 0.1;
  
  const forecasts = [];
  const baseRevenue = 24500;
  
  // Generate 30-day forecast
  for (let days = 1; days <= 30; days++) {
    const trendFactor = Math.pow(1 + currentTrend / 365, days);
    const seasonalFactor = 1 + seasonality;
    const randomFactor = 0.9 + Math.random() * 0.2; // ±10% random variation
    
    const forecastedRevenue = Math.round(baseRevenue * trendFactor * seasonalFactor * randomFactor);
    
    forecasts.push({
      date: new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      forecasted_revenue: forecastedRevenue,
      confidence_interval: {
        lower: Math.round(forecastedRevenue * 0.85),
        upper: Math.round(forecastedRevenue * 1.15)
      },
      factors: {
        trend_contribution: Math.round((trendFactor - 1) * 100),
        seasonal_contribution: Math.round(seasonalFactor * 100 - 100),
        confidence_score: 0.8 - (days / 30) * 0.3 // Confidence decreases over time
      }
    });
  }

  return {
    period_forecasted: '30_days',
    total_forecasted_revenue: forecasts.reduce((sum, f) => sum + f.forecasted_revenue, 0),
    average_daily_forecast: Math.round(forecasts.reduce((sum, f) => sum + f.forecasted_revenue, 0) / forecasts.length),
    growth_projection: currentTrend,
    forecasts: forecasts
  };
}

async function getDetailedRevenueBreakdown(period: string) {
  return {
    by_service_type: [
      { service: 'Standard Moving', revenue: 15600, percentage: 45 },
      { service: 'Packing Service', revenue: 8200, percentage: 24 },
      { service: 'Storage Solutions', revenue: 4800, percentage: 14 },
      { service: 'Insurance Upsells', revenue: 3200, percentage: 9 },
      { service: 'Cleaning Service', revenue: 2700, percentage: 8 }
    ],
    by_customer_segment: [
      { segment: 'Residential', revenue: 18500, percentage: 62 },
      { segment: 'Small Business', revenue: 8900, percentage: 30 },
      { segment: 'Corporate', revenue: 2400, percentage: 8 }
    ],
    by_geography: [
      { region: 'Stockholm', revenue: 12400, percentage: 42 },
      { region: 'Göteborg', revenue: 7200, percentage: 24 },
      { region: 'Malmö', revenue: 5100, percentage: 17 },
      { region: 'Other Cities', revenue: 5000, percentage: 17 }
    ],
    attribution_methods: [
      { method: 'Direct Conversion', revenue: 16800, confidence: 0.95 },
      { method: 'Assisted Conversion', revenue: 5700, confidence: 0.85 },
      { method: 'Influenced Conversion', revenue: 2200, confidence: 0.70 }
    ]
  };
}

// =============================================================================
// DATABASE OPERATIONS (MOCKED)
// =============================================================================

async function recordRevenueAttribution(data: any) {
  // Mock database insert - replace with actual database operation
  const attribution = {
    id: Math.floor(Math.random() * 100000),
    ...data,
    created_at: new Date().toISOString()
  };
  
  console.log('💾 Revenue attribution recorded in database', attribution);
  return attribution;
}