// Service Worker för Nordflytt Staff App
const CACHE_NAME = 'nordflytt-staff-v1'
const STATIC_CACHE_NAME = 'nordflytt-static-v1'
const DYNAMIC_CACHE_NAME = 'nordflytt-dynamic-v1'

// Static assets to cache
const STATIC_ASSETS = [
  '/staff',
  '/staff/dashboard',
  '/staff/schedule',
  '/staff/checkin',
  '/staff/chat',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
]

// API routes to cache dynamically
const API_ROUTES = [
  '/api/staff/',
  '/api/schedule/',
  '/api/checkin/',
  '/api/chat/'
]

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('Service Worker: Installing...')
  
  event.waitUntil(
    caches.open(STATIC_CACHE_NAME)
      .then(cache => {
        console.log('Service Worker: Caching static assets')
        return cache.addAll(STATIC_ASSETS)
      })
      .then(() => {
        console.log('Service Worker: Static assets cached')
        return self.skipWaiting()
      })
      .catch(error => {
        console.error('Service Worker: Error caching static assets', error)
      })
  )
})

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activating...')
  
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (cacheName !== STATIC_CACHE_NAME && cacheName !== DYNAMIC_CACHE_NAME) {
              console.log('Service Worker: Deleting old cache', cacheName)
              return caches.delete(cacheName)
            }
          })
        )
      })
      .then(() => {
        console.log('Service Worker: Activated')
        return self.clients.claim()
      })
  )
})

// Fetch event - handle requests with cache strategies
self.addEventListener('fetch', (event) => {
  const request = event.request
  const url = new URL(request.url)

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return
  }

  // Skip external requests
  if (url.origin !== location.origin) {
    return
  }

  // Handle different types of requests
  if (url.pathname.startsWith('/api/')) {
    // API requests - Network First strategy
    event.respondWith(networkFirstStrategy(request))
  } else if (url.pathname.startsWith('/staff')) {
    // Staff app pages - Cache First strategy
    event.respondWith(cacheFirstStrategy(request))
  } else {
    // Other requests - Network First strategy
    event.respondWith(networkFirstStrategy(request))
  }
})

// Cache First Strategy (for static assets and app pages)
async function cacheFirstStrategy(request) {
  try {
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      console.log('Service Worker: Serving from cache', request.url)
      return cachedResponse
    }

    console.log('Service Worker: Fetching from network', request.url)
    const networkResponse = await fetch(request)
    
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE_NAME)
      cache.put(request, networkResponse.clone())
    }
    
    return networkResponse
  } catch (error) {
    console.error('Service Worker: Cache first strategy failed', error)
    
    // Return offline page for navigation requests
    if (request.destination === 'document') {
      return caches.match('/staff/offline') || new Response(
        createOfflinePage(),
        { headers: { 'Content-Type': 'text/html' } }
      )
    }
    
    throw error
  }
}

// Network First Strategy (for API calls and dynamic content)
async function networkFirstStrategy(request) {
  try {
    console.log('Service Worker: Fetching from network first', request.url)
    const networkResponse = await fetch(request)
    
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE_NAME)
      cache.put(request, networkResponse.clone())
    }
    
    return networkResponse
  } catch (error) {
    console.log('Service Worker: Network failed, trying cache', request.url)
    const cachedResponse = await caches.match(request)
    
    if (cachedResponse) {
      console.log('Service Worker: Serving stale data from cache')
      return cachedResponse
    }
    
    // Return offline response for API calls
    if (request.url.includes('/api/')) {
      return new Response(
        JSON.stringify({ 
          error: 'Offline', 
          message: 'Denna funktion kräver internetanslutning',
          offline: true 
        }),
        { 
          status: 503,
          headers: { 'Content-Type': 'application/json' } 
        }
      )
    }
    
    throw error
  }
}

// Background Sync for offline actions
self.addEventListener('sync', (event) => {
  console.log('Service Worker: Background sync triggered', event.tag)
  
  if (event.tag === 'checkin-sync') {
    event.waitUntil(syncCheckinData())
  } else if (event.tag === 'schedule-sync') {
    event.waitUntil(syncScheduleData())
  } else if (event.tag === 'chat-sync') {
    event.waitUntil(syncChatMessages())
  }
})

// Sync functions for background sync
async function syncCheckinData() {
  try {
    const cache = await caches.open(DYNAMIC_CACHE_NAME)
    const requests = await cache.keys()
    
    const checkinRequests = requests.filter(req => 
      req.url.includes('/api/checkin') && req.method === 'POST'
    )
    
    for (const request of checkinRequests) {
      try {
        await fetch(request)
        await cache.delete(request)
        console.log('Service Worker: Synced checkin data')
      } catch (error) {
        console.error('Service Worker: Failed to sync checkin data', error)
      }
    }
  } catch (error) {
    console.error('Service Worker: Checkin sync failed', error)
  }
}

async function syncScheduleData() {
  try {
    // Fetch latest schedule data
    const response = await fetch('/api/staff/schedule')
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE_NAME)
      cache.put('/api/staff/schedule', response.clone())
      console.log('Service Worker: Schedule data synced')
    }
  } catch (error) {
    console.error('Service Worker: Schedule sync failed', error)
  }
}

async function syncChatMessages() {
  try {
    // Sync pending chat messages
    const pendingMessages = await getStoredMessages()
    
    for (const message of pendingMessages) {
      try {
        const response = await fetch('/api/chat/send', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(message)
        })
        
        if (response.ok) {
          await removeStoredMessage(message.id)
          console.log('Service Worker: Chat message synced')
        }
      } catch (error) {
        console.error('Service Worker: Failed to sync chat message', error)
      }
    }
  } catch (error) {
    console.error('Service Worker: Chat sync failed', error)
  }
}

// Helper functions for IndexedDB operations
async function getStoredMessages() {
  // In a real implementation, this would use IndexedDB
  return []
}

async function removeStoredMessage(messageId) {
  // In a real implementation, this would remove from IndexedDB
  console.log('Removing stored message', messageId)
}

// Push notification handling
self.addEventListener('push', (event) => {
  console.log('Service Worker: Push notification received')
  
  const options = {
    body: 'Du har nya meddelanden i Nordflytt Personal App',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: 'nordflytt-notification',
    actions: [
      {
        action: 'open',
        title: 'Öppna App',
        icon: '/icons/open-32x32.png'
      },
      {
        action: 'dismiss',
        title: 'Stäng',
        icon: '/icons/dismiss-32x32.png'
      }
    ],
    data: {
      url: '/staff/dashboard'
    }
  }

  if (event.data) {
    const data = event.data.json()
    options.body = data.message || options.body
    options.data.url = data.url || options.data.url
  }

  event.waitUntil(
    self.registration.showNotification('Nordflytt Personal', options)
  )
})

// Notification click handling
self.addEventListener('notificationclick', (event) => {
  console.log('Service Worker: Notification clicked')
  
  event.notification.close()
  
  if (event.action === 'dismiss') {
    return
  }
  
  const urlToOpen = event.notification.data?.url || '/staff/dashboard'
  
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then(clientList => {
        // Check if app is already open
        for (const client of clientList) {
          if (client.url.includes('/staff') && 'focus' in client) {
            client.navigate(urlToOpen)
            return client.focus()
          }
        }
        
        // Open new window if app is not open
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen)
        }
      })
  )
})

// Create offline page HTML
function createOfflinePage() {
  return `
    <!DOCTYPE html>
    <html lang="sv">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Offline - Nordflytt Personal</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: linear-gradient(135deg, #002A5C 0%, #004080 100%);
          color: white;
          margin: 0;
          padding: 20px;
          min-height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
          text-align: center;
        }
        .container {
          max-width: 400px;
          padding: 40px 20px;
        }
        .icon {
          width: 80px;
          height: 80px;
          background: rgba(255,255,255,0.2);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 auto 20px;
          font-size: 40px;
        }
        h1 {
          margin: 0 0 10px;
          font-size: 24px;
        }
        p {
          margin: 0 0 30px;
          opacity: 0.8;
          line-height: 1.5;
        }
        button {
          background: white;
          color: #002A5C;
          border: none;
          padding: 12px 24px;
          border-radius: 6px;
          font-size: 16px;
          font-weight: 600;
          cursor: pointer;
          transition: transform 0.2s;
        }
        button:hover {
          transform: translateY(-1px);
        }
        button:active {
          transform: translateY(0);
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="icon">📡</div>
        <h1>Ingen internetanslutning</h1>
        <p>Du är offline just nu. Vissa funktioner kan vara begränsade tills du återfår internetanslutning.</p>
        <button onclick="window.location.reload()">Försök igen</button>
      </div>
    </body>
    </html>
  `
}

console.log('Service Worker: Loaded successfully')